<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>tfecat</name>
			<script>local commands = {

  generate = function()
    catalog.export()
  end,
 
 
  transmit = function()
    -- if  (player and player ~= '') then
      catalog.transmit()
    -- else
      -- cecho('\n\n&lt;red&gt;CATALOG:&lt;white&gt; invalid player to transmit items to ' .. player .. '!\n\n')
    -- end
  end, 
  
  
  merge = function()
    if (tellData and tellData.result) then
      catalog.writeTellDataToDiff(function()
        catalog.mergeDiff(function()
          cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; merged!\n\n') 
        end)
      end)
    else
      catalog.mergeDiff(function()
        cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; merged!\n\n') 
      end)    
    end
  end,
  
  load = function()
    catalog.load(function()
      cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; loaded ' .. tostring(#catalog.itemsIndex) .. ' items into catalog.items!\n\n') 
    end)
  end,  
  
  summary = function()
    catalog.showSummary()
  end,
  
  diff = function()
    catalog.showDiff()
  end,
  
  
  update = function()
    catalog.install()
  end,
  
  
  help = function()
    cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; tfecat generate - generate list of new items\n') 
    cecho('&lt;green&gt;CATALOG:&lt;white&gt; tfecat transmit - upload generated list\n\n') 
    
    cecho('&lt;green&gt;CATALOG:&lt;white&gt; tfecat summary  - list the number of contributions from each account\n') 
    cecho('&lt;green&gt;CATALOG:&lt;white&gt; tfecat diff  - shows the items that are still pending\n\n')
     
    cecho('&lt;green&gt;CATALOG:&lt;white&gt; tfecat load  - refreshes the current catalog data for use by tcat\n') 
    cecho('&lt;green&gt;CATALOG:&lt;white&gt; tcat &lt;item&gt;  - searches the catalog for &lt;item&gt;\n\n') 
    
    cecho('&lt;orange&gt;CATALOG:&lt;white&gt; tfecat update   - update this package!\n\n') 
  end,




}

local cmd = matches[2]
local param = matches[3]

if (commands[cmd]) then
  commands[cmd](param)
else
  if (cmd and cmd ~= '') then
    cecho('\n\n&lt;orange&gt;CATALOG:&lt;white&gt; unknown command ' .. cmd .. '!\n') 
  end
  commands.help()
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^tfecat ?(\w*) ?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>tfecat search (tcat)</name>
			<script>
-- load items if not already loaded

if (not catalog.itemsIndex or #catalog.itemsIndex == 0) then
  cecho('\n&lt;green&gt;TFECAT: &lt;white&gt;loading items from server... please hold\n\n')
  local cmd = matches[1]
  catalog.load(function()
    expandAlias(cmd)
  end)
  return
end

if matches[2] == 'help' then
  cecho('&lt;green&gt;SYNTAX\n')
  cecho('\n')
  cecho('&lt;white&gt;tcat&lt;reset&gt;          - View the contents of your catalog\n')
  cecho('&lt;white&gt;tcat #&lt;reset&gt;        - View the catalog entry specified\n')
  cecho('&lt;white&gt;tcat &lt;text&gt;&lt;reset&gt;   - Search your catalog for names containing &lt;text&gt;\n')
  cecho('\n')
  cecho('&lt;green&gt;SEARCH OPTIONS\n')
  cecho('\n')
  cecho('&lt;white&gt;-l #[-#]&lt;reset&gt;               Show items that are level #, or between # and #\n')
  cecho('&lt;white&gt;-a &lt;stat&gt;&lt;reset&gt;              Show items that affect the stat specified\n')
  cecho('&lt;white&gt;-a &lt;stat&gt;.lt.#&lt;reset&gt;         Show items that affect the stat specifie by less than #\n')
  cecho('&lt;white&gt;-a &lt;stat&gt;.gt.#&lt;reset&gt;         Show items that affect the stat specified by more than #\n')
  cecho('&lt;white&gt;-w &lt;location&gt;&lt;reset&gt;          Show items that are worn in specified location\n')
  cecho('&lt;white&gt;-w &lt;location&gt;.&lt;layer&gt;&lt;reset&gt;  Show items that are worn in specified location and layer\n')
  cecho('&lt;white&gt;-p &lt;layer&gt;&lt;reset&gt;             Show items that are worn on specified layer.\n')
  
  cecho('&lt;white&gt;-A &lt;alignment&gt;&lt;reset&gt;         Show items that can be used by the alignment specified\n')
  cecho('&lt;white&gt;-c &lt;class&gt;&lt;reset&gt;             Show items that can be used by the class specified\n')
  cecho('&lt;white&gt;-g &lt;gender&gt;&lt;reset&gt;            Show items that can be used by the class specified\n')
  cecho('&lt;white&gt;-r &lt;race&gt;&lt;reset&gt;              Show items that can be used by the race specified\n')
  
  -- cecho('-f &lt;flag&gt;     Show items that have the specified anti-flag\n')
  -- cecho('-r &lt;flag&gt;     Show items that have the specified restriction flag\n')
  -- cecho('-m &lt;flag&gt;     Show items that have the specified material flag\n')
  
  cecho('&lt;white&gt;-t &lt;type&gt;&lt;reset&gt;              Show items that are of the specified type\n')
  cecho('&lt;white&gt;-W &lt;class&gt;&lt;reset&gt;             Show weapons of the specified weapon class\n')
  cecho('&lt;white&gt;-d #&lt;reset&gt;                   Show weapons with an average dps of at least #\n')  
  
  cecho('\n') 
  cecho('&lt;green&gt;SEARCH EXAMPLES\n')
  cecho('\n')
  
  cecho('Find all items between levels 1 and 20 that affect hit regen and go on the\n')
  cecho('body.base slot:\n')
  cecho('tcat -l 1-20 -a hit_regen -w body.base\n')
  cecho('\n')
  
  
  cecho('Find all items between levels 1 and 50 that reduce your wisdom\n')
  cecho('tcat -l 1-50 -a wisdom.lt.0\n')
  cecho('\n')  
  -- 
  cecho('Find all items that go in the hand slot and increase mana_regen for an ogre druid\n')
  cecho('can wear:\n')
  cecho('tcat -a mana_regen.gt.0 -w hands -c druid -r ogre\n')
  cecho('\n')
  
  cecho('Find all axe weapons between levels 1 and 40:\n')
  cecho('tcat -W axe -l 1-40\n')
  
  cecho('\n') 
  cecho('&lt;green&gt;OPTION DETAILS\n') 

  cecho('&lt;white&gt;Affects (-a):&lt;reset&gt; hit_points, hit_regen, mana_points, mana_regen, move_points,\n') 
  cecho('move_regen, strength, intelligence, wisdom, dexterity, constitution, magic,\n') 
  cecho('fire, cold, electricity, mind, acid, age, hitroll, damroll\n') 
  cecho('\n') 
  
  cecho('&lt;white&gt;Wear Locations (-w):&lt;reset&gt; finger, neck, body, head, legs, feet, hands, arms, waist,\n') 
  cecho('wrist, right_hand, left_hand, float_nearby, horse_body, horse_back, horse_foot\n') 
  cecho('\n') 
  
    
  cecho('&lt;white&gt;Wear Layers (-p):&lt;reset&gt; bottom, under, base, over, top\n') 
  cecho('\n') 
-- 
-- Anti-Flags (-f): anti-human, anti-elf, anti-gnome, anti-dwarf, anti-halfling,
-- anti-ent, anti-centaur, anti-lizardman, anti-ogre, anti-troll, anti-orc, anti-
-- goblin, anti-vyan, anti-mage, anti-cleric, anti-thief, anti-warrior, anti-
-- paladin, anti-ranger, anti-druid, anti-monk, anti-bard, anti-male, anti-
-- femaile, anti-good, anti-evil, only-good-evil, anti-lawful, anti-chaotic,
-- only-law-chaos

  cecho('&lt;white&gt;Item Types (-t):&lt;reset&gt; scroll, wand, weapon, armor, potion, key, other\n') 
  cecho('\n') 
  
  cecho('&lt;white&gt;Weapon Classes (-W):&lt;reset&gt; axe, bow, club, dagger, mace, polearm, spear, staff,\n') 
  cecho('sword, whip, unarmed\n') 
  
  
  cecho('&lt;white&gt;Aligntments (-A):&lt;reset&gt; CE, CG, CN, LE, LG, LN, NE, NG, PN\n') 
  cecho('\n') 
  
  return
end

local searchString = ' ' .. matches[2]

-- 
-- {
  -- Acid = 90,
  -- ["Anti-Flags"] = { "anti-mage", "anti-cleric", "anti-thief", "anti-bard" },
  -- ["Armor Class"] = 20,
  -- ["Base Cost"] = 18000,
  -- Cold = 99,
  -- Fire = 99,
  -- Layer = { "base" },
  -- Level = 45,
  -- Materials = { "mithril" },
  -- Rarity = "very rare",
  -- ["Unidentified Name"] = "A Pair Of Mithril Plate Cuisses",
  -- ["Wear Loc."] = { "legs" },
  -- Weight = 7.2,
  -- buffer = "                        A Pair Of Mithril Plate Cuisses\n    ...",
  -- datetime = 1612993408.648,
  -- itemType = "armor",
  -- name = "a pair of mithril plate cuisses",
  -- source = "Shazzul"
  -- affects = { {
    -- amount = -1,
    -- name = "Hitroll",
    -- type = "property"
  -- }, {
    -- amount = -1,
    -- name = "Damroll",
    -- type = "property"
  -- }, {
    -- amount = 20,
    -- name = "Mana_points",
    -- type = "property"
  -- }, {
    -- amount = 1,
    -- name = "Intelligence",
    -- type = "property"
  -- }, {
    -- name = "Is evil.",
    -- type = "affect"
  -- }
  -- },
-- }


local levQuery, levMin, levMax = rex.match(searchString, [[( -l (\d+)-?(\d*))]])

if (levQuery) then
  searchString = rex.gsub(searchString, levQuery, '')
  levMin = tonumber(levMin)
  if (levMax == '') then
    levMax = levMin
  else
    levMax = tonumber(levMax)
  end
end


local weapQuery, weapType = rex.match(searchString, [[( -W (\w+))]])
if (weapQuery) then
  searchString = rex.gsub(searchString, weapQuery, '')
end

local weapDpsQuery, weapDPS = rex.match(searchString, [[( -d (\d+\.?\d+))]])
if (weapDpsQuery) then
  searchString = rex.gsub(searchString, weapDpsQuery, '')
  weapDPS = tonumber(weapDPS)
end

local itemTypeQuery, itemType = rex.match(searchString, [[( -t (\w+))]])
if (itemTypeQuery) then
  searchString = rex.gsub(searchString, itemTypeQuery, '')
end


local alignQuery, align = rex.match(searchString, [[( -A (\w\w))]])
if (alignQuery) then
  searchString = rex.gsub(searchString, alignQuery, '')
end

local classQuery, charClass = rex.match(searchString, [[( -c (\w+))]])
if (classQuery) then
  searchString = rex.gsub(searchString, classQuery, '')
end

local genderQuery, gender = rex.match(searchString, [[( -g (\w+))]])
if (genderQuery) then
  searchString = rex.gsub(searchString, genderQuery, '')
end

local raceQuery, race = rex.match(searchString, [[( -r (\w+))]])
if (raceQuery) then
  searchString = rex.gsub(searchString, raceQuery, '')
end
    

local itemLocationQuery, location, layer = rex.match(searchString, [[( -w (\w+)\.?(\w*))]])
if (itemLocationQuery) then
  searchString = rex.gsub(searchString, itemLocationQuery, '')
end

local itemLayerQuery, xlayer = rex.match(searchString, [[( -p (\w+))]])
if (itemLayerQuery) then
  layer = xlayer
  searchString = rex.gsub(searchString, itemLayerQuery, '')
end

local affectQuery, affect, affectFilterType, affectFilterVal = rex.match(searchString, [[( -a (\w+)\.?(gte|lte|gt|lt|)\.?(-?\d*\.?\d*))]])
if (affectQuery) then
  searchString = rex.gsub(searchString, affectQuery, '')
end

-- display(levQuery, levMin, levMax)


-- remove the leading space we added (and any the user added)
searchString = rex.gsub(searchString, [[^\s+]], '')


-- display('ss: [' .. searchString .. ']')

-- if query has params pass through to the old catalog for now

if (rex.match(searchString, '-')) then
  cecho('\n&lt;orange&gt;TFECAT: &lt;white&gt;unknown tcat search option...\n\n')
  -- send(matches[1], false)
  return
end



if (rex.match(searchString, [[^\d+$]])) then
  catalog.displayItem(tonumber(searchString))
  return
end

-- display(params)


-- 
-- cecho(demonnic:cfText('Number', {alignment = "left", width = 6, nogap=true}) .. ' ')
-- cecho(demonnic:cfText('Name', {alignment = "left", width = 50, nogap=true}) .. ' ')
-- cecho(demonnic:cfText('Level  ', {alignment = "right", width = 7, nogap=true}) .. ' ')
-- cecho(demonnic:cfText('Type', {alignment = "left", width = 9, nogap=true}))
cecho('Number Name                                                Level  Type\n')
cecho('------ ----                                                -----  ----\n')

local hasAffect = function(item, affect, filterType, filterAmount)

-- affects = { {
    -- amount = -1,
    -- name = "Hitroll",
    -- type = "property"
  -- }
  
  affect = affect:lower()
  
  if (filterAmount ~= '') then
    filterAmount = tonumber(filterAmount)
  end
  
  if (item.affects) then
    for idx, aff in ipairs(item.affects) do 
      if (aff.type == 'property' and aff.name:lower() == affect) then
        if (
          filterType == '' or  
          filterAmount == '' or
          (filterType == 'gt' and aff.amount &gt; filterAmount) or 
          (filterType == 'gte' and aff.amount &gt;= filterAmount) or 
          (filterType == 'lt' and aff.amount &lt; filterAmount) or
          (filterType == 'lte' and aff.amount &lt;= filterAmount) or
          1 == 0
        ) then
          return true
        end
      end
    end
  end
  return false
end   
   
for idx, item in ipairs(catalog.itemsIndex) do
  data = catalog.items[item]
  flags = catalog.itemCalculated[item]
  
  if (
    (searchString == '' or rex.match(item .. ' ' .. data.name, [[(?i)]] .. searchString)) and
    (not levQuery or data.Level &lt;= levMax and data.Level &gt;= levMin) and
    (not weapQuery or (data.itemType == 'weapon' and data.Class == weapType)) and
    -- weapDpsQuery, weapDPS
    (not weapDpsQuery or (data.itemType == 'weapon' and data.averageDamage &gt;= weapDPS)) and
    -- --itemTypeQuery, itemType
    (not itemTypeQuery or data.itemType == itemType) and
    -- -- (itemLocationQuery, location, layer  
    (not itemLocationQuery or table.contains(data["Wear Loc."],location)) and
    (layer == nil or layer == '' or table.contains(data.Layer,layer)) and
    -- affectQuery, affect
    (not affectQuery or hasAffect(data, affect, affectFilterType, affectFilterVal)) and
    
    (not alignQuery or flags.charAlignments[align]) and
    (not classQuery or flags.charClasses[charClass]) and
    (not genderQuery or flags.charGenders[gender]) and
    (not raceQuery or flags.charRaces[race]) and
       -- 
    -- local alignQuery, align = rex.match(searchString, [[( -A (\w\w))]])
    -- local classQuery, charClass = rex.match(searchString, [[( -c (\w+))]])
    -- local genderQuery, gender = rex.match(searchString, [[( -g (\w+))]])
    -- local raceQuery, race = rex.match(searchString, [[( -r (\w+))]])

    
    1 == 1
  ) then
 
    
    local vnum = '[' .. demonnic:cfText('&lt;green&gt;' .. tostring(idx) .. '&lt;reset&gt;', {alignment="right", width=4, nogap=true}) .. ']'
    
    cechoLink(vnum, function() catalog.displayItem(idx) end, "display item", true)    
    cecho(' ' .. demonnic:cfText(string.sub(data.name, 1, 50), {alignment = "left", width = 50, nogap=true}) .. ' ')
    
    cecho(demonnic:cfText(tostring(data.Level) .. '  ', {alignment = "right", width = 7, nogap=true}) .. ' ')
    cecho(demonnic:cfText(tostring(data.itemType), {alignment = "left", width = 9, nogap=true}) .. ' ')    
    
    if (data.itemType == 'weapon') then
      cecho(string.format("%.1f", data.averageDamage or 0) .. ' dps' .. ' (' .. data.Class .. ')')
    end
    
    if (data.itemType == 'armor') then
      cecho('AC: ' .. tostring(data["Armor Class"]))
    end
    
    cecho('\n')
    
  end
  
  
  
  
  
end

</script>
			<command></command>
			<packageName></packageName>
			<regex>^tcat ?(.*)$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>catalog_export</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>JSON</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
common = common or {}

--
-- json.lua
--
-- Copyright (c) 2019 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\\\",
  [ "\"" ] = "\\\"",
  [ "\b" ] = "\\b",
  [ "\f" ] = "\\f",
  [ "\n" ] = "\\n",
  [ "\r" ] = "\\r",
  [ "\t" ] = "\\t",
}

local escape_char_map_inv = { [ "\\/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return escape_char_map[c] or string.format("\\u%04x", c:byte())
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val &lt;= -math.huge or val &gt;= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;id=iws-appendixa
  local f = math.floor
  if n &lt;= 0x7f then
    return string.char(n)
  elseif n &lt;= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n &lt;= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n &lt;= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(3, 6),  16 )
  local n2 = tonumber( s:sub(9, 12), 16 )
  -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local has_unicode_escape = false
  local has_surrogate_escape = false
  local has_escape = false
  local last
  for j = i + 1, #str do
    local x = str:byte(j)

    if x &lt; 32 then
      decode_error(str, j, "control character in string")
    end

    if last == 92 then -- "\\" (escape char)
      if x == 117 then -- "u" (unicode escape sequence)
        local hex = str:sub(j + 1, j + 5)
        if not hex:find("%x%x%x%x") then
          decode_error(str, j, "invalid unicode escape in string")
        end
        if hex:find("^[dD][89aAbB]") then
          has_surrogate_escape = true
        else
          has_unicode_escape = true
        end
      else
        local c = string.char(x)
        if not escape_chars[c] then
          decode_error(str, j, "invalid escape char '" .. c .. "' in string")
        end
        has_escape = true
      end
      last = nil

    elseif x == 34 then -- '"' (end of string)
      local s = str:sub(i + 1, j - 1)
      if has_surrogate_escape then
        s = s:gsub("\\u[dD][89aAbB]..\\u....", parse_unicode_escape)
      end
      if has_unicode_escape then
        s = s:gsub("\\u....", parse_unicode_escape)
      end
      if has_escape then
        s = s:gsub("\\.", escape_char_map_inv)
      end
      return s, j + 1

    else
      last = x
    end
  end
  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx &lt;= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end


common.json = json</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>catalog</name>
				<packageName></packageName>
				<script>catalog = catalog or {}
catalog.events = catalog.events or {}

catalog.events.CHECK_PROMPT =  'tfecat: checked yo prompt'

catalog.items = catalog.items or {}
catalog.itemsIndex = catalog.itemsIndex or {}
catalog.itemCalculated = catalog.itemCalculated or {}

catalog.summary = catalog.summary or {}

catalog.parsing = false

catalog.serverUrl = 'http://vault-thirteen.net:49160' 



local titleCase = function(first, rest )
   return first:upper()..rest:lower()
end



catalog.displayItem = function(idx)
  
  local item = catalog.items[catalog.itemsIndex[idx]]

  
  cecho('\n\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n')
  if (item.name:lower() ~= item['Unidentified Name']:lower()) then
    local ts = string.gsub(item.name, "(%a)([%w_']*)", titleCase) 
    local title = demonnic:cfText('&lt;white&gt;' .. ts, {alignment = "center", width = 80, nogap=true})
    cecho(title .. '\n')
    cecho(demonnic:cfText(rex.gsub(ts, '[^ ]', '-'), {alignment = "center", width = 80, nogap=true}) .. '\n')
    

  end
  cecho(item.buffer)
  cecho('\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n')
  -- cecho('Identified: ' .. item.name .. '\n')
  -- cecho('Source: ' .. item.source .. '\n')
  -- cecho('-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n')
  -- 
end


-- this is the code that will be in the one liner to export
catalog.install = function ()
  
  local URL = "https://github.com/njs50/tfecat/raw/master/mudlet/tfecat.module/tfecat.xml"
  
  local downloadHandler, installHandler
  
  local log = function(msg) 
    cecho('\n&lt;green&gt;TFECAT: &lt;white&gt;package ' .. msg .. '!\n') 
  end
  
  downloadHandler = registerAnonymousEventHandler("sysDownloadDone", function(_, filename)
    if not filename:find("tfecat.xml", 1, true) then 
      return 
    end
    killAnonymousEventHandler(downloadHandler)
    log('downloaded')
    
    installPackage(filename)
    os.remove(filename)

  end)
  
  installHandler = registerAnonymousEventHandler("sysInstallPackage", function(_, name)
    -- stop if what got installed isn't my thing
    if name ~= "tfecat" then 
      return 
    end
    
    killAnonymousEventHandler(installHandler)
    log('installed')
  
    expandAlias('tfecat help')
  
  end)
  
  log('uninstalling any existing...')
  uninstallPackage('tfecat')
  tempTimer(5, function()
    log('downloading...')
    downloadFile(getMudletHomeDir().."/tfecat.xml", URL .. '?_=' .. tostring(getEpoch))
  end)

end


catalog.transmit = function(player)

  local filepath = getMudletHomeDir().."/catalog_dif.json"
  
  local file, s, catJson = io.open(filepath)
  if file then 
    catJson = file:read("*all"); 
    io.close(file) 
  end
      
  postHTTP(catJson, catalog.serverUrl .. "/catalog/diff", {["Content-type"] = "application/json"})
  
  cecho('\n&lt;green&gt;TFECAT: &lt;white&gt;new items sent to server!\n')


end



catalog.export = function(cb)

  catalog.load( function(publicCatalog)
    
    catalog.getAllItems(function(items)
      
      cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt;loaded ' .. tostring(#table.keys(publicCatalog)) .. ' items from github!\n\n')
      
      local newItems = #table.keys(items)
      if (newItems &gt; 0) then
        local filepath = getMudletHomeDir().."/catalog_dif.json"
        local file = io.open(filepath,"w")
        file:write(common.json.encode(items))
        file:close()
        cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; ' .. tostring(newItems) .. ' new items written to ' .. filepath .. '\n\n') 
      else
        cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; no new items to export!\n\n') 
      end
      
      if (cb) then
        cb(items)
      end
            
    end)
    
  end)

end



catalog.mergeDiff = function(cb)

  local filepath = getMudletHomeDir().."/catalog_dif.json"
  local outputFile = getMudletHomeDir().."/catalog.json"

  catalog.load(function(publicCatalog) 
  
    cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt;loaded ' .. tostring(#table.keys(publicCatalog)) .. ' items from github!\n\n')
  
    local file, s, catJson = io.open(filepath)
    
    if file then 
      catJson = file:read("*all"); 
      io.close(file) 
    end  
    
    local diffItems = common.json.decode(catJson)
    
    local diffCount = 0
    
    for itemName, item in pairs(diffItems) do
      
      if (not publicCatalog[itemName]) then
        publicCatalog[itemName] = item
        diffCount = diffCount + 1
      end
      
    end
    
    if (diffCount &gt; 0) then
      cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; ' .. tostring(diffCount) .. ' new items added to catalog\n\n')
      local outfile = io.open(outputFile,"w")
      outfile:write(common.json.encode(publicCatalog))
      outfile:close()
    else
      cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; no new items to merge to catalog!\n\n')
    end
 
  end)

end


catalog.load = function(cb)
  
  local src='https://raw.githubusercontent.com/njs50/tfecat/master/public/catalog.json'

  local downloadHandler

  
  -- register our function to run on the event that something was downloaded
  downloadHandler = registerAnonymousEventHandler("sysDownloadDone", function(_, filename)
    -- is the file that downloaded ours?
    if not filename:find("catalog.json", 1, true) then return end
    
    killAnonymousEventHandler(downloadHandler)
    
    -- read the contents of the webpage in
    local file, s, catJson = io.open(filename)
    
    if file then 
      catJson = file:read("*all"); 
      io.close(file) 
    end
    
    -- delete the file on disk, don't clutter
    os.remove(filename)
  
  
    catalog.items = common.json.decode(catJson)
    catalog.itemsIndex = table.keys(catalog.items)
    
    -- process anti flags
    for idx, item in pairs(catalog.items) do
    
      local newFlags = {}
      
      newFlags.charAlignments = {
        LG = true,
        LN = true,
        LE = true,
        NG = true,
        PN = true,
        NE = true,
        CG = true,
        CN = true,
        CE = true,
      }

      newFlags.charRaces = {
        ogre = true,
        troll = true,
        orc = true,
        vyan = true,
        goblin = true,
        human = true,
        lizardfolk = true,
        dwarf = true,
        halfling = true,
        gnome = true,
        ent = true,
        elf = true,
        centaur = true,
      }

      newFlags.charClasses = {
        bard = true,
        cleric = true,
        druid = true,
        mage = true,
        monk = true,
        paladin = true,
        ranger = true,
        thief = true,
        warrior = true,
      }

      newFlags.charGenders = {
        male = true,
        female = true,
      }    
      
      -- -- process anti flags
      if (item["Anti-Flags"]) then
        
        for idx, flag in ipairs(item["Anti-Flags"]) do
        
          flag = rex.gsub(flag, [[^anti-]], '');
          flag = rex.gsub(flag, [[^lizardman]], 'lizardfolk');
          
          if (newFlags.charRaces[flag]) then
          
            newFlags.charRaces[flag] = false
            
          elseif (newFlags.charClasses[flag]) then
            
            newFlags.charClasses[flag] = false
            
          elseif (newFlags.charGenders[flag]) then
          
            newFlags.charGenders[flag] = false
            
          elseif flag == 'good' then
          
            newFlags.charAlignments.LG = false;
            newFlags.charAlignments.NG = false;
            newFlags.charAlignments.CG = false;
           
          elseif flag == 'evil' then
          
            newFlags.charAlignments.LE = false;
            newFlags.charAlignments.NE = false;
            newFlags.charAlignments.CE = false;
            
          elseif flag == 'lawful' then
          
            newFlags.charAlignments.LG = false;
            newFlags.charAlignments.LN = false;
            newFlags.charAlignments.LE = false;
           
          elseif flag == 'chaotic' then
          
            newFlags.charAlignments.CG = false;
            newFlags.charAlignments.CN = false;
            newFlags.charAlignments.CE = false;
           
          elseif flag == 'only-good-evil' then
          
            newFlags.charAlignments.LN = false;
            newFlags.charAlignments.TN = false;
            newFlags.charAlignments.CN = false;
            
          elseif flag == 'only-law-chaos' then
          
            newFlags.charAlignments.NG = false;
            newFlags.charAlignments.TN = false;
            newFlags.charAlignments.NE = false;
            
          else
            error('Unknown anti flag! - ' .. flag)
          end -- flag cases
        
        end -- anti flag loop
        
      end -- if has anti-flags
    
      if (item.Restrictions and table.contains(item.Restrictions, 'bladed')) then
        newFlags.charClasses.cleric = false;
        newFlags.charClasses.druid = false;
      end

      if (item.Restrictions and table.contains(item.Restrictions, 'dishonorable')) then
        newFlags.charClasses.paladin = false;
      end
    
      catalog.itemCalculated[idx] = newFlags
      
    end -- item loop
    
    if (cb) then
      cb(catalog.items)
    end

  end)
  
  -- download a list of fake users for a demo
  downloadFile(getMudletHomeDir().."/catalog.json", src .. '?_=' .. tostring(getEpoch))



end

catalog.loadFile = function(src, cb)

  local downloadHandler
  local srcFilename = rex.match(src, [[^.*/(.*)$]])
  
  -- register our function to run on the event that something was downloaded
  downloadHandler = registerAnonymousEventHandler("sysDownloadDone", function(_, filename)
    -- is the file that downloaded ours?
    if not filename:find(srcFilename, 1, true) then return end
    
    killAnonymousEventHandler(downloadHandler)
    
    -- read the contents of the webpage in
    local file, s, catJson = io.open(filename)
    
    if file then 
      catJson = file:read("*all"); 
      io.close(file) 
    end
    
    -- delete the file on disk, don't clutter
    os.remove(filename)

    if (cb) then
      cb(common.json.decode(catJson))
    end

  end)
  
  downloadFile(getMudletHomeDir().."/" .. srcFilename, src .. '?_=' .. tostring(getEpoch))

end


catalog.showSummary = function()
  
  catalog.loadFile('https://raw.githubusercontent.com/njs50/tfecat/master/public/summary.json', function(summary)
    catalog.summary = summary
    
    local st = demonnic.TableMaker:new({
      edgeCharacter = '|'
    })
    
    
    st:addColumn({name = "Account", width = 25, textColor = "&lt;green&gt;"})
    st:addColumn({name = "Items", width = 20, textColor = "&lt;white&gt;"})
    st:addColumn({name = "Unprocessed Items", width = 20, textColor = "&lt;purple&gt;"})
    
    
    catalog.loadFile(catalog.serverUrl .. "/catalog/summary", function(pending)
          
      for sucker, count in pairs(pending) do
        
        local pending = count - (summary[sucker] or 0)
        count = count - pending
        
        st:addRow({sucker, tostring(count), tostring(pending)})
      end
      
      cecho(st:assemble())
    
    end)
    
  end)

end



catalog.showDiff = function()
  
  catalog.loadFile('https://raw.githubusercontent.com/njs50/tfecat/master/public/catalog.json', function(published)
    catalog.summary = summary
    
    local st = demonnic.TableMaker:new({
      edgeCharacter = '|'
    })
    
    
    st:addColumn({name = "Account", width = 15, textColor = "&lt;green&gt;"})
    st:addColumn({name = "Item", width = 40, textColor = "&lt;white&gt;"})
    st:addColumn({name = "Item", width = 25, textColor = "&lt;white&gt;"})
    
    catalog.loadFile(catalog.serverUrl .. "/catalog", function(pending)
          
      for item, itemData in pairs(pending) do
        
        if (not published[item]) then
          st:addRow({itemData.source, item, '&lt;green&gt;added'})
        end
       
        if (published[item] and published[item].source ~= itemData.source) then
          st:addRow({itemData.source, item, '&lt;red&gt;updated ' .. published[item].source})
        end
       
        
      end
      
      cecho(st:assemble())
    
    end)
    
  end)

end


catalog.prevLines = 500
catalog.prevCols = 300

catalog.setColors = function(cb)

  tempRegexTrigger([[^\s+Lines \((\d+)\)\s+Columns \((\d+)\)\s*$]], function()
    
    catalog.prevLines = matches[2]
    catalog.prevCols = matches[3]

    if (cb) then
      tempTrigger([[Number of screen columns set to]], cb, 1);
    end
    
    send('color lines 500 &amp; color columns 300')
    
  end, 1)
  
  
  -- make sure prompt has a newline on the end of it
  registerAnonymousEventHandler(catalog.events.CHECK_PROMPT, function(_, prompt)
    catalog.originalPrompt = prompt
    if (not rex.find(catalog.originalPrompt, [[%\\$]])) then
      cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; setting prompt to one with more and ending in newline!\n\n')
      send([[prompt ?p' -- MORE -- '&lt;%f?f|@R%hhp@n @G%ee@n @B?m'[%mmv]'!m'%vmv'@n %gwm %xxp?l' %llhp' %d?b' %c'&gt;%\]])
    end  
  end, true)

  
  send('color &amp; prompt') 

end

catalog.resetColors = function(cb)
  
  -- reset prompt if needed
  registerAnonymousEventHandler(catalog.events.CHECK_PROMPT, function(_, prompt)
    if (catalog.originalPrompt ~= prompt) then
      cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; reseting prompt to orignal value!\n\n') 
      send('prompt ' .. catalog.originalPrompt)
    end  
  end, true)
  
  
   if (cb) then
    tempTrigger([[Number of screen columns set to]], cb, 1);
  end
  send('prompt &amp; color lines ' .. tostring(catalog.prevLines) .. ' &amp; color columns ' .. tostring(catalog.prevCols))  

end


catalog.getAllItems = function(cb)
  
  catalog.setColors(function()
    
    catalog.getItemList(function(itemList)
    
      catalog.itemGetLoop(itemList, function(items)
        -- restore previous settings
        catalog.resetColors()
        cecho('\n\n&lt;green&gt;CATALOG:&lt;white&gt; parsed all items in catalog!\n\n') 
        cb(items)  
        
      end)

    end)
    
  end)


end


catalog.itemGetLoop = function(items, cb)
  
  local dt = getEpoch()

  local newItems = {}

  co = coroutine.create(function()
  
    for itemId, itemStub in pairs(items) do 
    
      -- display(itemId)
      
      catalog.getItem(itemId, function(item) 

        
        item.name = itemStub.name
        item.itemType = itemStub.itemType
        item.datetime = dt
        
        newItems[item.name] = item
        
        coroutine.resume(co)
      end)
      
      coroutine.yield()
    
    end
    
    cb(newItems)
  
  end)

  coroutine.resume(co)


end





catalog.getItemList = function(cb)

  tempRegexTrigger([[^Number\s+Name\s+Level\s+Type\s*$]], function()
  
    cecho('\n&lt;green&gt;CATALOG: &lt;white&gt;parsing catalog list\n\n')
    
    local temptrigs = {}
    local items = {}
    
    -- trigger to hit enter on any "more" prompts
    temptrigs.moreCatcher = tempRegexTrigger([[^\s*--\s+MORE\s+--\s*&lt;]], function ()
      send('\n')
      -- send('sigh')
      cecho('\n&lt;green&gt;CATALOG: &lt;white&gt;continuing catalog listing\n\n')
    end)
    
    
    temptrigs.catEntryCatcher = tempRegexTrigger([[^\[\s*(\d+)\]\s*(.+?)\s+(\d+)\s+(\S+)]], function ()
      
      if (not catalog.items[matches[3]]) then
        cecho(' &lt;-- &lt;green&gt;CATALOG: &lt;white&gt;new item\n')
        items[matches[2]] = {
          name = matches[3],
          -- level = tonumber(matches[4]),
          itemType = matches[5],
        }
      end
    end)
    

    -- next regular prompt means we're done
    tempRegexTrigger([[^&lt;]], function ()
      killTrigger(temptrigs.moreCatcher)
      killTrigger(temptrigs.catEntryCatcher)
      temptrigs.moreCatcher = nil
      temptrigs.catEntryCatcher = nil
      cecho('\n&lt;green&gt;CATALOG: &lt;white&gt;catalog listing ended\n\n')
      cb(items)
    end, 1)  
  
  end, 1)
  
  send('catalog')

end


catalog.getItem = function(itemId, cb)
  
  tempRegexTrigger([[You read catalog entry #]] .. tostring(itemId) .. [[\.$]], function ()
    
    local splitString = function(str) 
      local ret = {}
      for i in str:gmatch("[^ ,]+") do
         table.insert(ret, i)
      end
      return ret
    end
    
    local joinString = function(tbl, joiner)
      local str = ''
      for k, v in pairs(tbl) do
        str = str .. v .. joiner
      end
      return str
    end
    
    local catalogId = matches[3]
    
    cecho('\n&lt;green&gt;CATALOG: &lt;white&gt;parsing an item\n\n')
    
    local item = { 
      buffer = {}, 
    }
    
    
    local temptrigs = {}
    
    temptrigs.catEntryCatcher = tempRegexTrigger([[^.*$]], function ()
    	  
      if (rex.match(matches[1], [[^\s*(-=)+-\s*$]])) then
      
        if (item.parsingStarted) then
          item.parsingEnding = true
        else
          item.parsingStarted = true
        end
        
        
      elseif (item.parsingStarted and not item.parsingEnding) then 
      
        table.insert(item.buffer, matches[1])
        
        -- find anything like "foo: bar"
        for i, j in rex.gmatch(matches[1], [[(?:\s\s+|^\s*)(\S+[ -]?\S+):\s+(\S.*?)(?:\s\s|\s*$)]]) do
          -- display(i,j)
          item[i] = j
        end
        
        
      end       
        

        
      
      -- catch affects
      if (item.matchAffects) then
        
        item.affects = item.affects or {}
        if matches[1] == '' then
          item.matchAffects = nil
        else
        
          local aff = rex.gsub(matches[1], [[^\s+]], '')
          
           local affectMissingDot = {
              ["Grants Haste"] = true,
            }
    
          -- handle affects that are split over two lines (no . on the end of em :p)
          if (#item.affects &gt; 0) then

            local lastItem = item.affects[#item.affects]
            
            if not affectMissingDot[lastIte] and rex.match(lastItem, [[[^.]$]]) then
              lastItem = lastItem .. ' ' .. aff
              item.affects[#item.affects] = lastItem
            else 
             table.insert(item.affects, aff)
            end
          else
            table.insert(item.affects, aff)
          end  
        end
        
      end
      
      
      if (item.parsingEnding) then
      
   	
        -- clear things we don't want to record
        item.parsingEnding = nil
        item.parsingStarted = nil
        
        -- kill those triggers
        for k, v in pairs(temptrigs) do
          killTrigger(v)
        end
        
        -- reformat affects
        if (item.affects) then
          local newAffects = {}
          for k, v in pairs(item.affects) do
            local aff = { name = v, type = 'affect' }
            if (rex.match(v, [[ by [+-]\d+\.?\d*\.$]])) then
              aff.name = rex.gsub(v, [[^(.*)( by .*)$]], '%1')
              aff.type = 'property'
              aff.amount = rex.gsub(v, [[^(.* by \+?)(.*)\.$]], '%2')
              aff.amount = tonumber(aff.amount)
            end
            table.insert(newAffects, aff)
          end
          item.affects = newAffects
        end
        
        -- reformat things which are arrays
        local arrayProps = { 'Restrictions', 'Wear Loc.', 'Layer', 'Anti-Flags', 'Materials' } 
        
        for i, k in ipairs(arrayProps) do
          if (item[k]) then
            item[k] = string.split(item[k], ', ')
          end
        end
        
        -- turn numbers back into numbers
        for key, val in pairs(item) do
        
          if (not table.contains(arrayProps, key) and not table.contains({'buffer', 'affects'}, key)) then
            
            local match = rex.match(val, [[^(\d+(\.\d+)?)(?:\s+lbs|%)?$]])
            
            if (match) then
              item[key] = tonumber(match)
            end
              
          end
        
        end
        
        -- if item has Damage calc the average damage:
          if(item.Damage) then
            rex.gsub(item.Damage, [[^(\d+)d(\d+)\+?(\d+)?$]], function(n, d, b)
              item.averageDamage = ((d + 1) / 2) * n
              if (b) then 
               item.averageDamage = item.averageDamage + b 
              end
          end)
        end
        
        
        item["Unidentified Name"] = rex.gsub(item.buffer[1], [[^\s*(.+?)\s*$]], '%1')
        
        item.buffer = joinString(item.buffer, '\n')
        
        item.source = gmcp.Char.Score.account
        
        cb(item)      
      
      end  
      
    end)
    
    
    temptrigs.affects = tempRegexTrigger([[^\s*Affects:]], function ()
      	item.matchAffects = true
    end)
    -- 
    -- 
    -- temptrigs.weapon = tempRegexTrigger([[Damage:\s+(\S+)\s+Class:\s+(.+?)\s+Attack:]], function ()
    	-- item.damage = matches[2]
      -- item.weaponClass = matches[3]
      -- item.itemType = 'weapon'
      -- 
      -- rex.gsub(item.damage, [[^(\d+)d(\d+)\+?(\d+)?$]], function(n, d, b)
        -- item.averageDamage = ((d + 1) / 2) * n
        -- if (b) then 
          -- item.averageDamage = item.averageDamage + b 
        -- end
      -- end)
      -- 
      -- cecho('\nAverage Damage: ' .. tostring(item.averageDamage) .. '\n')
      -- 
    -- end)
    -- 
    
  
  end, 1) -- end of read catalog entry temp regex.


  send('catalog -b ' .. tostring(itemId))

end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>demonnic</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TextFormatter</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>standaloneFormatter</name>
					<packageName></packageName>
					<script>--- fText processing
-- @module demonnic
demonnic = demonnic or {}

function demonnic:wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic:wordWrap(str, options.effWidth)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then
    error("Improper argument: options expected to be passed as table")
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.nogap == nil then options.nogap = false end
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorReset = "&lt;r&gt;"
    options.colorPattern = "&lt;%d+,%d+,%d+:?%d*,?%d*,?%d*&gt;"
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "#FFFFFF"
    options.spacerColor = options.spacerColor or "#FFFFFF"
    options.textColor = options.textColor or "#FFFFFF"
    options.colorReset = "#r"
    options.colorPattern = 'c|%d%d%d%d%d%d'
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorReset = "&lt;reset&gt;"
    options.colorPattern = "&lt;%w*_?%w*:?%w*_?%w*&gt;"
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorReset = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = string.gsub(tostring(str), options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
  options.rightCap = options.cap
  options.capLen = string.len(options.cap)
  local gapSpaces = 0
  if not options.nogap then
    if options.alignment == "center" then
      gapSpaces = 2
    else
      gapSpaces = 1
    end
  end
  options.nontextlength = options.width - options.strLen - gapSpaces
  options.leftPadLen = math.floor(options.nontextlength / 2)
  options.rightPadLen = options.nontextlength - options.leftPadLen
  options.effWidth = options.width - ((options.capLen * gapSpaces) + gapSpaces)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    if not options.nogap then str = string.format(" %s ", str) end

  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    if not options.nogap then str = string.format(" %s", str) end

  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    if not options.nogap then str = string.format("%s ", str) end
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing.
  local fullLeftCap = string.format("%s%s%s", options.capColor, leftCap, options.colorReset)
  local fullLeftSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (leftPadLen - capLen)), options.colorReset)
  local fullText = string.format("%s%s%s", options.textColor, str, options.colorReset)
  local fullRightSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (rightPadLen - capLen)), options.colorReset)
  local fullRightCap = string.format("%s%s%s", options.capColor, rightCap, options.colorReset)

  if options.inside then
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne"
  -- "endcap================= some text"
  -- "some text =================endcap"
    local finalString = string.format("%s%s%s%s%s", fullLeftCap, fullLeftSpacer, fullText, fullRightSpacer, fullRightCap)
    return finalString
  else
  --"=====endcap some text endcap====="
  --"=====endcap some text pacdne====="
  --"=================endcap some text"
  --"some text endcap================="

    local finalString = string.format("%s%s%s%s%s", fullLeftSpacer, fullLeftCap, fullText, fullRightCap, fullRightSpacer)
    return finalString
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."

  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"

  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"

  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>reusableFormatter</name>
					<packageName></packageName>
					<script>--- Stand alone text formatter object. Remembers the options you set and can be adjusted as needed
-- @module demonnic.textFormatter
demonnic.TextFormatter = {}
demonnic.TextFormatter.validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}

--- Set's the formatting type whether it's for cecho, decho, or hecho
--@tparam string typeToSet What type of formatter is this? Valid options are { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}
function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

--- Sets whether or not we should do word wrapping.
--@tparam boolean shouldWrap should we do wordwrapping?
function demonnic.TextFormatter:setWrap(shouldWrap)
  local argumentType = type(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. argumentType .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

--- Sets the width we should format for
--@tparam number width the width we should format for
function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

--- Sets the cap for the formatter
--@tparam string cap the string to use for capping the formatted string.
function demonnic.TextFormatter:setCap(cap)
  local argumentType = type(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. argumentType) end
  self.options.cap = cap
end

--- Sets the color for the format cap
--@tparam string capColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setCapColor(capColor)
  local argumentType = type(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. argumentType) end
  self.options.capColor = capColor
end

--- Sets the color for spacing character
--@tparam string spacerColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local argumentType = type(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. argumentType) end
  self.options.spacerColor = spacerColor
end

--- Sets the color for formatted text
--@tparam string textColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setTextColor(textColor)
  local argumentType = type(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. argumentType) end
  self.options.textColor = textColor
end

--- Sets the spacing character to use. Should be a single character
--@tparam string spacer the character to use for spacing
function demonnic.TextFormatter:setSpacer(spacer)
  local argumentType = type(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. argumentType) end
  self.options.spacer = spacer
end

--- Set the alignment to format for
--@tparam string alignment How to align the formatted string. Valid options are 'left', 'right', or 'center'
function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

--- Set whether the the spacer should go inside the the cap or outside of it
--@tparam boolean spacerInside 
function demonnic.TextFormatter:setInside(spacerInside)
  local argumentType = type(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. argumentType)
  end
  self.options.inside = spacerInside
end

--- Set whether we should mirror/reverse the caps. IE &lt;&lt; becomes &gt;&gt; if set to true
--@tparam boolean shouldMirror
function demonnic.TextFormatter:setMirror(shouldMirror)
  local argumentType = type(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. argumentType)
  end
  self.options.mirror = shouldMirror
end

--- Format a string based on the stored options
--@tparam string str The string to format
function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

--- Creates and returns a new TextFormatter. For valid options, please see https://github.com/demonnic/fText/wiki/fText
--@tparam table options the options for the text formatter to use when running format()
function demonnic.TextFormatter:new(options)
  if options == nil then options = {} end
  if options and type(options) ~= "table" then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  local me = {}
  me.options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  }
  for option, value in pairs(options) do
    me.options[option] = value
  end
  setmetatable(me, self)
  self.__index = self
  return me
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tableFormatter</name>
					<packageName></packageName>
					<script>--- Easy formatting for text tables
-- @module demonnic.TableMaker

demonnic.TableMaker = {
  headCharacter = "*",
  footCharacter = "*",
  edgeCharacter = "*",
  rowSeparator = "-",
  separator = "|",
  colorReset = "&lt;reset&gt;",
  formatType = "c",
  printHeaders = true,
  autoEcho = false,
}

function demonnic.TableMaker:checkPosition(position, func)
  if position == nil then position = 0 end
  if type(position) ~= "number" then
    if tonumber(position) then
      position = tonumber(position)
    else
      error(func .. ": Argument error: position expected as number, got " .. type(position))
    end
  end
  return position
end

function demonnic.TableMaker:insert(tbl, pos, item)
  if pos ~= 0 then
    table.insert(tbl, pos, item)
  else
    table.insert(tbl, item)
  end
end

--- Adds a column definition for the table. 
--@tparam table options Table of options suitable for a TextFormatter object. See https://github.com/demonnic/fText/wiki/fText
--@tparam number position The position of the column you're adding, counting from the left. If not provided will add it as the last column
function demonnic.TableMaker:addColumn(options, position)
  if options == nil then options = {} end
  if not type(options) == "table" then error("demonnic.TableMaker:addColumn(options, position): Argument error: options expected as table, got " .. type(options)) end
  local options = table.deepcopy(options)
  position = self:checkPosition(position, "demonnic.TableMaker:addColumn(options, position)")
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self:insert(self.columns, position, formatter)
end

--- Deletes a column at the given position
--@tparam number position the column you wish to delete
function demonnic.TableMaker:deleteColumn(position)
  if position == nil then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position)
  local maxColumn = #self.columns
  if position &gt; maxColumn then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position provided was larger than number of columns in the table. Number of columns: " .. #self.columns) end
  table.remove(self.columns, position)
end

--- Replaces a column at a specific position with the newly provided formatting
--@tparam table options table of options suitable for a TextFormatter object. See https://github.com/demonnic/fText/wiki/fText
--@tparam number position which column you are replacing, counting from the left.
function demonnic.TableMaker:replaceColumn(options, position)
  if position == nil then
    error("demonnic.TableMaker:replaceColumn(options, position): Argument error: position as number expected, got nil")
  end
  position = self:checkPosition(position)
  if type(options) ~= "table" then error("demonnic.TableMaker:replaceColumn(options, position): Argument error: options as table expected, got " .. type(options)) end
  if #self.columns &lt; position then error("demonnic.TableMaker:replaceColumn(options, position): you cannot specify a position higher than the number of columns currently in the TableMaker. You sent:" .. position .. " and there are: " .. #self.columns .. "columns in the TableMaker") end
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self.columns[position] = formatter
end

--- Adds a row of output to the table
--@tparam table columnEntries This indexed table contains an entry for each column in the table. Entries in the table must be strings, a table of options for insertPopup or insertLink, or a function which returns one of these things
--@tparam number position position for the row you want to add, counting from the top down. If not provided defaults to the last line in the table.
function demonnic.TableMaker:addRow(columnEntries, position)
  local columnEntriesType = type(columnEntries)
  if columnEntriesType ~= "table" then
    error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries expected as table, got " .. columnEntriesType)
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument Error, you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries items expected as string, got:" .. type(entry)) 
      end
    end
  end
  position = self:checkPosition(position, "demonnic.TableMaker:addRow(columnEntries, position)")
  self:insert(self.rows, position, columnEntries)
end

--- Deletes the row at the given position
--@tparam number position the row to delete
function demonnic.TableMaker:deleteRow(position)
  if position == nil then error("demonnic.TableMaker:deleteRow(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position, "demonnic.TableMaker:deleteRow(position)")
  local maxRow = #self.rows
  if position &gt; maxRow then error("demonnic.TableMaker:deleteRow(position): Argument Error: position given was &gt; the number of rows we have # of rows is:" .. maxRow) end
  table.remove(self.rows, position)
end

--- Replaces a row of output in the table
--@tparam table columnEntries This indexed table contains an entry for each column in the table. Entries in the table must be strings, a table of options for insertPopup or insertLink, or a function which returns one of these things
--@tparam number position position for the row you want to add, counting from the top down.
function demonnic.TableMaker:replaceRow(columnEntries, position)
  if position == nil then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): ArgumentError: position expected as number, received nil")
  end
  position = self:checkPosition(position, "demonnic.TableMaker:replaceRow(columnEntries, position)")
  if #self.rows &lt; position then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): position cannot be greater than the number of rows already in the tablemaker. You provided: " .. position .. " and there are " .. #self.rows .. "rows in the TableMaker")
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument Error: you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument error: columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  self.rows[position] = columnEntries
end

function demonnic.TableMaker:checkEntry(entry)
  local allowedTypes = {
    "string"
  }
  if self.allowPopups then
    table.insert(allowedTypes, "table")
  end
  local entryType = type(entry)
  if entryType == "function" then
    entryType = type(entry())
  end
  if table.contains(allowedTypes, entryType) then
    return entry
  else
    return 0
  end
end

function demonnic.TableMaker:checkNumber(num)
  if num == nil then num = 0 end
  if not tonumber(num) then num = 0 end
  return tonumber(num)
end

--- Sets a specific cell's display information
--@tparam number row the row number of the cell, counted from the top down
--@tparam number column the column number of the cell, counted from the left
--@param entry What to set the entry to. Must be a string, or a table of options for insertLink/insertPopup if allowPopups is set. Or a function which returns one of these things
function demonnic.TableMaker:setCell(row, column, entry)
  local maxRow = #self.rows
  local maxColumn = #self.columns
  local ae = "demonnic.TableMaker:setCell(row, column, entry): Argument Error:"
  row = self:checkNumber(row)
  if row == 0 then error(ae .. " row must be a number, you provided " .. type(row)) end
  column = self:checkNumber(column)
  if column == 0 then error(ae .. " column must be a number, you provided " .. type(column)) end
  if row &gt; maxRow then error(ae .. " row is higher than the number of rows in the table. Highest row:" .. maxRow) end
  if column &gt; maxColumn then error(ae .. " column is higher than the number of columns in the table. Highest column:" .. maxColumn) end
  local entryType = type(entry)
  entry = self:checkEntry(entry)
  if entry == 0 then
    if type(entry) == "function" then 
      error(ae .. " entry was provided as a function, but does not return a string. We need a string in the end")
    else 
      error("demonnic.TableMaker:setCell(row, column, entry): Argument Error: entry must be a string, or a function which returns a string. You provided a " .. entryType)
    end
  end
  self.rows[row][column] = entry
end

function demonnic.TableMaker:totalWidth()
  local width = 0
  local numberOfColumns = #self.columns
  local separatorWidth = string.len(self.separator)
  local edgeWidth = string.len(self.edgeCharacter) * 2
  for _,column in ipairs(self.columns) do
    width = width + column.options.width
  end
  separatorWidth = separatorWidth * (numberOfColumns - 1)
  width = width + edgeWidth + separatorWidth
  return width
end

function demonnic.TableMaker:getType()
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, self.formatType) then
    return 'd'
  elseif table.contains(hex, self.formatType) then
    return 'h'
  elseif table.contains(col, self.formatType) then
    return 'c'
  else
    return ''
  end
end

function demonnic.TableMaker:echo(message, echoType, ...)
  local fType = self:getType()
  local consoleType = type(self.autoEchoConsole)
  local console = ""
  if echoType == nil then echoType = "" end
  if consoleType == "string" then
    console = self.autoEchoConsole
  else
    console = self.autoEchoConsole.name
  end
  local functionName = string.format("%secho%s", fType, echoType)
  local func = _G[functionName]
  if fType == "" then formatted = false end
  if echoType == "" then
    func(console, message)
  else
    func(console, message, ...)
  end
end

function demonnic.TableMaker:scanRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local rowText = ""
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset

  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    local thisLine = ec
    for index,column in ipairs(columns) do
      if index == 1 then
        thisLine = string.format("%s%s", thisLine, column[i])
      else
        thisLine = string.format("%s%s%s", thisLine, sep, column[i])
      end
    end
    thisLine = string.format("%s%s", thisLine, ec)
    if rowText == "" then
      rowText = thisLine
    else
      rowText = string.format("%s\n%s", rowText, thisLine)
    end
  end
  return rowText
end

function demonnic.TableMaker:echoRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    if type(str) == "table" then 
      str = str[1]
    end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    self:echo(ec)
    for index,column in ipairs(columns) do
      local message = column[i]
      if index ~= 1 then 
        self:echo(sep)
      end
      if type(row[index]) == "string" then
        self:echo(message)
      elseif type(row[index]) == "table" then
        local rowEntry = row[index]
        local echoType = ""
        if type(rowEntry[2]) == "string" then
          echoType = "Link"
        elseif type(rowEntry[2]) == "table" then
          echoType = "Popup"
        end
        self:echo(message, echoType, rowEntry[2], rowEntry[3], rowEntry[4] or true)
      end
    end
    self:echo(ec)
    if i ~= linesInRow then
      self:echo("\n")
    end
  end
end

function demonnic.TableMaker:makeHeader()
  local totalWidth = self:totalWidth()
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  local header = self.frameColor .. string.rep(self.headCharacter, totalWidth) .. self.colorReset
  local columnHeaders = ""
  if self.printHeaders then
    local columnEntries = {}
    for _,v in ipairs(self.columns) do
      table.insert(columnEntries, v:format(v.options.name))
    end
    local divWithNewlines = string.format("\n%s", self:createRowDivider())
    columnHeaders = string.format("\n%s%s%s%s", ec, table.concat(columnEntries, sep), ec, divWithNewlines)
  end
  header = string.format("%s%s", header, columnHeaders)
  return header
end

function demonnic.TableMaker:createRowDivider()
  local columnPieces = {}
  for _,v in ipairs(self.columns) do
    local piece = string.format("%s%s%s", self.separatorColor, string.rep(self.rowSeparator, v.options.width), self.colorReset)
    table.insert(columnPieces, piece)
  end
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  return string.format("%s%s%s", ec, table.concat(columnPieces, sep), ec)
end

--- enables making cells which incorporate insertLink/insertPopup
function demonnic.TableMaker:enablePopups()
  self.autoEcho = true
  self.allowPopups = true
end

--- enables autoEcho so that when assemble is called it echos automatically
function demonnic.TableMaker:enableAutoEcho()
  self.autoEcho = true
end

--- disables autoecho. Cannot be used if allowPopups is set
function demonnic.TableMaker:disableAutoEcho()
  if self.allowPopups then
    error("demonnic.TableMaker:disableAutoEcho(): you cannot disable autoEcho once you have enabled popups.")
  else
    self.autoEcho = false
  end
end

--- Enables automatically clearing the miniconsole we echo to
function demonnic.TableMaker:enableAutoClear()
  self.autoClear = true
end

--- Disables automatically clearing the miniconsole we echo to
function demonnic.TableMaker:disableAutoClear()
  self.autoClear = false
end

--- Set the miniconsole to echo to
--@param console The miniconsole to autoecho to. Set to "main" or do not pass the parameter to autoecho to the main console. Can be a string name of the console, or a Geyser MiniConsole
function demonnic.TableMaker:setAutoEchoConsole(console)
  local funcName = "demonnic.TableMaker:setAutoEchoConsole(console)"
  if console == nil then 
    console = "main" 
  end
  local consoleType = type(console)
  if consoleType ~= "string" and consoleType ~= "table" then
    error(funcName .. " ArgumentError: console as string or Geyser.MiniConsole expected, got " .. consoleType)
  elseif consoleType == "table" and console.type ~= "miniConsole" then
    error(funcName .. " ArgumentError: console received was a table and may be a Geyser object, but console.type is not miniConsole, it is " .. console.type)
  end
  self.autoEchoConsole = console
end

--- Assemble the table. If autoEcho is enabled/set to true, will automatically echo. Otherwise, returns the formatted string to echo the table
function demonnic.TableMaker:assemble()
  if self.allowPopups and self.autoEcho then
    self:popupAssemble()
  else
    return self:textAssemble()
  end
end

function demonnic.TableMaker:popupAssemble()
  if self.autoClear then
    local console = self.autoEchoConsole
    if console and console ~= "main" then
      if type(console) == "table" then
        console = console.name
      end
      clearWindow(console)
    end
  end
  local divWithNewLines = string.format("\n%s\n", self:createRowDivider())
  local header = self:makeHeader() .. "\n"
  local footer = string.format("\n%s%s%s\n", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  self:echo(header)
  for _,row in ipairs(self.rows) do
    if _ ~= 1 then
      self:echo(divWithNewLines)
    end
    self:echoRow(row)
  end
  self:echo(footer)
end

function demonnic.TableMaker:textAssemble()
  local sheet = ""
  local rows = {}
  for _,row in ipairs(self.rows) do
    table.insert(rows, self:scanRow(row))
  end
  local divWithNewlines = string.format("\n%s\n", self:createRowDivider())
  local footer = string.format("%s%s%s", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  sheet = string.format("%s\n%s\n%s\n", self:makeHeader(), table.concat(rows, divWithNewlines), footer)
  if self.autoEcho then
    local console = self.autoEchoConsole or "main"
    if type(console) == "table" then console = console.name end
    if self.autoClear and console ~= "main" then
      clearWindow(console)
    end
    self:echo(sheet)
  end
  return sheet
end

--- Creates and returns a new TableMaker. See https://github.com/demonnic/fText/wiki/TableMaker for valid entries to the options table.
--@tparam table options table of options for the TableMaker object
function demonnic.TableMaker:new(options)
  local funcName = "emonnic.TableMaker:new(options)"
  local me = {}
  setmetatable(me, self)
  self.__index = self
  if options == nil then options = {} end
  if type(options) ~= "table" then
    error("demonnic.TableMaker:new(options): ArgumentError: options expected as table, got " .. type(options))
  end
  local options = table.deepcopy(options)
  if options.allowPopups == true then
    options.autoEcho = true
  else
    options.allowPopups = false
  end
  local columns = false
  if options.columns then
    if type(options.columns) ~= "table" then error("demonnic.TableMaker:new(options): option error: You provided an options.columns entry of type " .. type(options.columns) .. " and columns must a table with entries suitable for demonnic.TableFormatter:addColumn().") end
    columns = table.deepcopy(options.columns)
    options.columns = nil
  end
  local rows = false
  if options.rows then
    if type(options.rows) ~= "table" then error("demonnic.tableMaker:new(options): option error: You provided an options.rows entry of type " .. type(options.rows) .. " and rows must be a table with entrys suitable for demonnic.TableFormatter:addRow()") end
    rows = table.deepcopy(options.rows)
    options.rows = nil
  end
  for option, value in pairs(options) do
    me[option] = value
  end
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, me.formatType) then
    me.frameColor = me.frameColor or "&lt;255,255,255&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;r&gt;"
  elseif table.contains(hex, me.formatType) then
    me.frameColor = me.frameColor or "#ffffff"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "#r"
  elseif table.contains(col, me.formatType) then
    me.frameColor = me.frameColor or "&lt;white&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;reset&gt;"
  else
    me.frameColor = ""
    me.separatorColor = ""
    me.colorReset = ""
  end
  me.columns = {}
  me.rows = {}
  if columns then
    for _,column in ipairs(columns) do
      me:addColumn(column)
    end
  end
  if rows then
    for _,row in ipairs(rows) do
      me:addRow(row)
    end
  end
  return me
end
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
